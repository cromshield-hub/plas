#include "plas/configspec/spec_registry.h"

#include <filesystem>
#include <fstream>
#include <map>
#include <mutex>
#include <sstream>

#include <nlohmann/json.hpp>
#include <yaml-cpp/yaml.h>

#include "plas/core/error.h"
#include "spec_registry_internal.h"

namespace plas::configspec {

// --- Builtin spec data (generated by CMake) ---

struct BuiltinSpecEntry {
    const char* name;
    const char* content;
};

extern const BuiltinSpecEntry kBuiltinSpecs[];
extern const std::size_t kBuiltinSpecCount;

// --- YAML-to-JSON helper (replicated from plas-core's private source) ---

namespace {

nlohmann::json YamlNodeToJson(const YAML::Node& node) {
    switch (node.Type()) {
        case YAML::NodeType::Null:
            return nullptr;

        case YAML::NodeType::Scalar: {
            try {
                auto val = node.as<bool>();
                auto raw = node.Scalar();
                if (raw == "true" || raw == "false" || raw == "True" ||
                    raw == "False" || raw == "TRUE" || raw == "FALSE" ||
                    raw == "yes" || raw == "no" || raw == "Yes" ||
                    raw == "No" || raw == "YES" || raw == "NO" ||
                    raw == "on" || raw == "off" || raw == "On" ||
                    raw == "Off" || raw == "ON" || raw == "OFF") {
                    return val;
                }
            } catch (...) {
            }

            try {
                auto val = node.as<int64_t>();
                if (std::to_string(val) == node.Scalar() ||
                    node.Scalar() == "0") {
                    return val;
                }
            } catch (...) {
            }

            try {
                auto val = node.as<double>();
                return val;
            } catch (...) {
            }

            return node.as<std::string>();
        }

        case YAML::NodeType::Sequence: {
            auto arr = nlohmann::json::array();
            for (const auto& item : node) {
                arr.push_back(YamlNodeToJson(item));
            }
            return arr;
        }

        case YAML::NodeType::Map: {
            auto obj = nlohmann::json::object();
            for (const auto& pair : node) {
                obj[pair.first.as<std::string>()] = YamlNodeToJson(pair.second);
            }
            return obj;
        }

        default:
            return nullptr;
    }
}

nlohmann::json ParseContent(const std::string& content,
                             config::ConfigFormat fmt) {
    if (fmt == config::ConfigFormat::kYaml) {
        YAML::Node root = YAML::Load(content);
        return YamlNodeToJson(root);
    }
    return nlohmann::json::parse(content);
}

config::ConfigFormat DetectFormatFromPath(const std::string& path) {
    auto dot = path.rfind('.');
    if (dot == std::string::npos) return config::ConfigFormat::kJson;
    std::string ext = path.substr(dot);
    if (ext == ".yaml" || ext == ".yml") return config::ConfigFormat::kYaml;
    return config::ConfigFormat::kJson;
}

std::string ExtractDriverName(const std::string& filename) {
    // "aardvark.schema.yaml" -> "aardvark"
    auto pos = filename.find(".schema.");
    if (pos != std::string::npos) return filename.substr(0, pos);
    // Try ".spec." pattern too
    pos = filename.find(".spec.");
    if (pos != std::string::npos) return filename.substr(0, pos);
    // fallback: strip extension
    auto dot = filename.rfind('.');
    if (dot != std::string::npos) return filename.substr(0, dot);
    return filename;
}

}  // namespace

// --- Impl ---

struct SpecRegistry::Impl {
    mutable std::mutex mutex;
    std::map<std::string, nlohmann::json> driver_specs;
    nlohmann::json config_spec;
    bool config_spec_set = false;
    bool builtins_loaded = false;
};

// --- Singleton ---

SpecRegistry& SpecRegistry::GetInstance() {
    static SpecRegistry instance;
    return instance;
}

SpecRegistry::SpecRegistry() : impl_(std::make_unique<Impl>()) {}
SpecRegistry::~SpecRegistry() = default;

// --- Registration ---

void SpecRegistry::RegisterBuiltinSpecs() {
    std::lock_guard<std::mutex> lock(impl_->mutex);
    if (impl_->builtins_loaded) return;

    for (std::size_t i = 0; i < kBuiltinSpecCount; ++i) {
        const auto& entry = kBuiltinSpecs[i];
        std::string name(entry.name);
        try {
            auto json = ParseContent(entry.content, config::ConfigFormat::kYaml);
            if (name == "device_config") {
                impl_->config_spec = std::move(json);
                impl_->config_spec_set = true;
            } else {
                impl_->driver_specs[name] = std::move(json);
            }
        } catch (...) {
            // Skip malformed builtin specs
        }
    }
    impl_->builtins_loaded = true;
}

core::Result<void> SpecRegistry::RegisterDriverSpec(
    const std::string& name, const std::string& content,
    config::ConfigFormat fmt) {
    try {
        auto json = ParseContent(content, fmt);
        std::lock_guard<std::mutex> lock(impl_->mutex);
        impl_->driver_specs[name] = std::move(json);
        return core::Result<void>::Ok();
    } catch (...) {
        return core::Result<void>::Err(core::ErrorCode::kInvalidArgument);
    }
}

core::Result<void> SpecRegistry::RegisterDriverSpecFromFile(
    const std::string& name, const std::string& path,
    config::ConfigFormat fmt) {
    if (fmt == config::ConfigFormat::kAuto) {
        fmt = DetectFormatFromPath(path);
    }
    std::ifstream file(path);
    if (!file.is_open()) {
        return core::Result<void>::Err(core::ErrorCode::kNotFound);
    }
    std::ostringstream ss;
    ss << file.rdbuf();
    return RegisterDriverSpec(name, ss.str(), fmt);
}

core::Result<void> SpecRegistry::RegisterConfigSpec(
    const std::string& content, config::ConfigFormat fmt) {
    try {
        auto json = ParseContent(content, fmt);
        std::lock_guard<std::mutex> lock(impl_->mutex);
        impl_->config_spec = std::move(json);
        impl_->config_spec_set = true;
        return core::Result<void>::Ok();
    } catch (...) {
        return core::Result<void>::Err(core::ErrorCode::kInvalidArgument);
    }
}

// --- Query ---

bool SpecRegistry::HasDriverSpec(const std::string& name) const {
    std::lock_guard<std::mutex> lock(impl_->mutex);
    return impl_->driver_specs.count(name) > 0;
}

bool SpecRegistry::HasConfigSpec() const {
    std::lock_guard<std::mutex> lock(impl_->mutex);
    return impl_->config_spec_set;
}

std::vector<std::string> SpecRegistry::RegisteredDrivers() const {
    std::lock_guard<std::mutex> lock(impl_->mutex);
    std::vector<std::string> result;
    result.reserve(impl_->driver_specs.size());
    for (const auto& kv : impl_->driver_specs) {
        result.push_back(kv.first);
    }
    return result;
}

core::Result<std::string> SpecRegistry::ExportDriverSpec(
    const std::string& name) const {
    std::lock_guard<std::mutex> lock(impl_->mutex);
    auto it = impl_->driver_specs.find(name);
    if (it == impl_->driver_specs.end()) {
        return core::Result<std::string>::Err(core::ErrorCode::kNotFound);
    }
    return core::Result<std::string>::Ok(it->second.dump(2));
}

// --- Directory loading ---

core::Result<std::size_t> SpecRegistry::LoadSpecsFromDirectory(
    const std::string& dir) {
    namespace fs = std::filesystem;
    std::error_code ec;
    if (!fs::is_directory(dir, ec)) {
        return core::Result<std::size_t>::Err(core::ErrorCode::kNotFound);
    }

    std::size_t count = 0;
    for (const auto& entry : fs::directory_iterator(dir, ec)) {
        if (!entry.is_regular_file()) continue;
        auto filename = entry.path().filename().string();

        bool is_yaml = filename.find(".schema.yaml") != std::string::npos ||
                       filename.find(".schema.yml") != std::string::npos ||
                       filename.find(".spec.yaml") != std::string::npos ||
                       filename.find(".spec.yml") != std::string::npos;
        bool is_json = filename.find(".schema.json") != std::string::npos ||
                       filename.find(".spec.json") != std::string::npos;
        if (!is_yaml && !is_json) continue;

        auto fmt = is_yaml ? config::ConfigFormat::kYaml
                           : config::ConfigFormat::kJson;
        auto name = ExtractDriverName(filename);

        std::ifstream file(entry.path());
        if (!file.is_open()) continue;
        std::ostringstream ss;
        ss << file.rdbuf();

        if (name == "device_config") {
            auto result = RegisterConfigSpec(ss.str(), fmt);
            if (result.IsOk()) ++count;
        } else {
            auto result = RegisterDriverSpec(name, ss.str(), fmt);
            if (result.IsOk()) ++count;
        }
    }
    return core::Result<std::size_t>::Ok(count);
}

// --- Reset ---

void SpecRegistry::Reset() {
    std::lock_guard<std::mutex> lock(impl_->mutex);
    impl_->driver_specs.clear();
    impl_->config_spec = nlohmann::json();
    impl_->config_spec_set = false;
    impl_->builtins_loaded = false;
}

// --- Internal accessors for Validator ---

namespace detail {

const nlohmann::json* GetDriverSpecJson(const SpecRegistry& registry,
                                         const std::string& name) {
    auto* impl = SpecRegistryAccessor::GetImpl(registry);
    std::lock_guard<std::mutex> lock(impl->mutex);
    auto it = impl->driver_specs.find(name);
    if (it == impl->driver_specs.end()) return nullptr;
    return &it->second;
}

const nlohmann::json* GetConfigSpecJson(const SpecRegistry& registry) {
    auto* impl = SpecRegistryAccessor::GetImpl(registry);
    std::lock_guard<std::mutex> lock(impl->mutex);
    if (!impl->config_spec_set) return nullptr;
    return &impl->config_spec;
}

}  // namespace detail

}  // namespace plas::configspec
